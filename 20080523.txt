As suggested by Dscho, I implemented path_list_append_strategy() which
fixed t6028-merge-up-to-date.sh.

Now the only failing test is t7600-merge.sh: its 14th, 15th, 16th and
22th testcase fails.

After a quick&dirty implementation of -n, only the last one fails.

And that was only a whitespace issue, now all tests pass. A milestone!

I also got an idea: a rebase history.

You have older commits after a rebase in your reflog but that's local.
If somebody steals my notebook, I loose them. And I plan to rebase (-i)
quite frequently. So here is my plan: save the old heads before a rebase
in a dedicated branch.

(The current ree of HEAD is 532da334ab7d90c5feb69b7a91f48d4962f8d984.)

The first time it's like this:

----
$ echo "Rebasing to Junio's master, excludes 4 documentation fixes." \
	| git commit-tree HEAD^{tree} -p HEAD
3114b6d7eb96b9c35eab9b0dc7f50af954ae96e0
$ git checkout -b rebase-history 3114b6d7eb96b9c35eab9b0dc7f50af954ae96e0
$ git checkout builtin-merge
$ git rebase -i junio/master # and here I really delete those 4 bogus commits
----

and now I can rebase without hiding any history from Dscho.

Next time it's almost the same but I do a merge:

----
$ echo "Moving commits not modifying builtin-merge.c to the start of the series." \
	| git commit-tree HEAD^{tree} -p refs/heads/rebase-history -p HEAD
53840b3f0be85e75120f5774d068fd74a5446ae5
$ git update-ref refs/heads/rebase-history 53840b3f0be85e75120f5774d068fd74a5446ae5
$ git rebase -i junio/master # and here I squash bugfixes
----

it will look like a merge but nobody will ever imagine what kind of
merge strategy I used! ;-)

Ok, seriously:

* I think it's really cool that Git allows me to do so.

* Maybe it would be interesting for others as well, maybe even it would
  worth writing a howto about this and send is as PATCH/RFC to the list.
